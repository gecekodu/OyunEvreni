<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MEB Lazer Fizik - Tam Ekran</title>
    <style>
        :root {
            --bg: #050510;
            --panel: #141420;
            --neon: #00f3ff;
            --laser: #ff0055;
            --gold: #ffd700;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Segoe UI', sans-serif;
            color: white;
            touch-action: none;
            user-select: none;
            /* Mobilde tam ekran deneyimi i√ßin g√∂vdeyi sabitle */
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* √úst Bilgi */
        header {
            height: 60px;
            background: rgba(20, 20, 32, 0.95);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            border-bottom: 1px solid #333;
            z-index: 10;
        }

        .status-group { display: flex; gap: 20px; align-items: center; }

        .status-box {
            font-weight: bold;
            font-size: 1rem;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        /* Oyun Sahnesi */
        canvas {
            display: block;
            flex-grow: 1;
            background: radial-gradient(circle at center, #1b1b2f 0%, #000 100%);
            cursor: crosshair;
        }

        /* Alt Kontrol */
        footer {
            height: 90px;
            background: var(--panel);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
            border-top: 1px solid var(--neon);
            box-shadow: 0 -5px 20px rgba(0, 243, 255, 0.1);
            padding-bottom: env(safe-area-inset-bottom); /* iPhone √ßentiƒüi i√ßin */
        }

        .drag-source {
            width: 60px;
            height: 60px;
            border: 2px dashed var(--neon);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            transition: 0.2s;
        }
        .drag-source:active { transform: scale(0.95); }

        .drag-icon {
            width: 40px;
            height: 4px;
            background: var(--neon);
            transform: rotate(-45deg);
            box-shadow: 0 0 10px var(--neon);
        }

        .trash { font-size: 2rem; color: #555; transition: 0.2s; }
        .trash.active { color: #ff0055; transform: scale(1.2); }

        /* Aray√ºz Katmanlarƒ± */
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 16, 0.98);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .btn {
            background: var(--neon);
            color: #000;
            border: none;
            padding: 15px 50px;
            font-size: 1.3rem;
            font-weight: bold;
            border-radius: 50px;
            margin-top: 30px;
            cursor: pointer;
            box-shadow: 0 0 25px var(--neon);
            transition: transform 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .btn:active { transform: scale(0.95); }

        .hidden { display: none !important; }

        .hint {
            position: absolute;
            bottom: 100px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.4);
            pointer-events: none;
            font-size: 0.9rem;
        }
        
        .mute-btn {
            background: transparent; border: 1px solid #555; color: #aaa;
            padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 0.8rem;
        }

        .game-title {
            font-size: clamp(2rem, 8vw, 3.5rem);
            color: white;
            text-shadow: 0 0 10px var(--neon), 0 0 20px var(--neon);
            margin-bottom: 10px;
            font-weight: 800;
        }

        .game-desc {
            font-size: 1.1rem;
            color: #ccc;
            max-width: 600px;
            line-height: 1.5;
        }
    </style>

    <style>
/* OYUN SONU MODAL STƒ∞LLERƒ∞ */
.gameOverModal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    opacity: 1;
    transition: opacity 0.3s ease;
}

.gameOverModal.hidden {
    display: none;
    opacity: 0;
}

.gameOverModalContent {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 20px;
    padding: 40px;
    text-align: center;
    color: white;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    max-width: 90%;
    animation: modalSlideIn 0.5s ease;
}

@keyframes modalSlideIn {
    from {
        transform: translateY(-50px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.gameOverModalContent h2 {
    font-size: 28px;
    margin: 0 0 20px 0;
}

.gameOverInfo {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 10px;
    padding: 20px;
    margin: 20px 0;
}

.gameOverInfo p {
    margin: 10px 0;
    font-size: 18px;
}

.earnedPoints {
    font-size: 20px;
    font-weight: bold;
    color: #ffd700;
}

#earnedPointsDisplay {
    font-size: 26px;
    font-weight: bold;
    color: #ffff00;
}

.gameOverBtn {
    background-color: white;
    color: #667eea;
    border: none;
    padding: 15px 40px;
    font-size: 18px;
    font-weight: bold;
    border-radius: 10px;
    cursor: pointer;
    margin-top: 10px;
    margin-left: 5px;
    margin-right: 5px;
    transition: all 0.3s ease;
    min-width: auto;
    flex: 1;
}

.gameOverBtn.primary {
    background: #10b981;
    color: white;
    border: 2px solid #10b981;
}

.gameOverBtn.secondary {
    background: transparent;
    color: #fff;
    border: 2px solid rgba(255,255,255,0.6);
}

.gameOverBtn:hover {
    transform: scale(1.05);
}

.gameOverBtn:active {
    transform: scale(0.95);
}

.gameOverBtnContainer {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
    margin-top: 20px;
}
    </style>
</head>
<body>

<div id="game-container">
    <header>
        <div class="status-group">
            <div class="status-box" style="color:white" id="level-display">B√∂l√ºm 1</div>
            <div class="status-box" style="color:var(--gold)" id="score-display">Puan: 0</div>
        </div>
        <div class="status-group">
            <div class="status-box" style="color:var(--neon)" id="mirror-display">Ayna: 3</div>
            <button class="mute-btn" onclick="game.audio.toggle()">üîä Ses</button>
        </div>
    </header>

    <canvas id="gameCanvas"></canvas>
    
    <div class="hint">Aynayƒ± s√ºr√ºkle, √ßevirmek i√ßin tƒ±kla.</div>

    <footer>
        <div class="trash" id="trash-zone">üóëÔ∏è</div>
        <div class="drag-source" id="spawner">
            <div class="drag-icon"></div>
            <span style="font-size:10px; color:#aaa; margin-top:5px;">YENƒ∞ AYNA</span>
        </div>
    </footer>
</div>

<div id="start-screen" class="overlay">
    <div class="game-title">LAZER Fƒ∞Zƒ∞K</div>
    <p class="game-desc">I≈üƒ±ƒüƒ±n yansƒ±masƒ± prensibini kullanarak lazeri hedefe ula≈ütƒ±r.</p>
    <button class="btn" onclick="game.start()">OYUNA BA≈ûLA</button>
</div>

<div id="win-screen" class="overlay hidden">
    <h1 style="color:var(--gold); font-size:2.5rem;">HEDEF VURULDU!</h1>
    <h2 style="color:white; margin:10px 0;" id="level-score-detail">+10 Puan</h2>
    <p id="level-stats" style="color:#aaa;">Az ayna, √ßok puan!</p>
    <button class="btn" onclick="game.nextLevel()">SONRAKƒ∞ B√ñL√úM</button>
</div>

<div id="end-screen" class="overlay hidden">
    <h1 style="color:var(--neon)">OYUN Bƒ∞TTƒ∞</h1>
    <p style="color:#ccc;">Toplam Skorun:</p>
    <h2 style="font-size:4rem; color:var(--gold); margin:10px 0;" id="final-score">0</h2>
    <p id="final-comment" style="color:#fff;"></p>
    <button class="btn" onclick="location.reload()">BA≈ûA D√ñN</button>
</div>



[Image of Reflection of light on a plane mirror]


<script>
class AudioController {
    constructor() { this.ctx = null; this.enabled = true; }
    init() {
        if (!this.ctx) { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); }
        if (this.ctx.state === 'suspended') { this.ctx.resume(); }
    }
    toggle() { this.enabled = !this.enabled; return this.enabled ? "üîä Ses" : "üîá Sessiz"; }
    playTone(freq, type, duration, vol = 0.1) {
        if (!this.enabled || !this.ctx) return;
        const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        osc.connect(gain); gain.connect(this.ctx.destination); osc.start(); osc.stop(this.ctx.currentTime + duration);
    }
    playPlace() { this.playTone(600, 'sine', 0.1); setTimeout(() => this.playTone(400, 'sine', 0.1), 50); }
    playRotate() { this.playTone(150, 'square', 0.05, 0.05); }
    playReflect() { this.playTone(1200, 'triangle', 0.05, 0.02); }
    playWin() {
        const now = this.ctx.currentTime;
        this.playNote(523.25, now); this.playNote(659.25, now + 0.1); this.playNote(783.99, now + 0.2); this.playNote(1046.50, now + 0.3, 0.4);
    }
    playNote(freq, time, dur=0.1) {
        if (!this.enabled || !this.ctx) return;
        const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
        osc.type = 'square'; osc.frequency.setValueAtTime(freq, time); gain.gain.setValueAtTime(0.05, time);
        gain.gain.linearRampToValueAtTime(0, time + dur); osc.connect(gain); gain.connect(this.ctx.destination); osc.start(time); osc.stop(time + dur);
    }
    playGameOver() {
        const now = this.ctx.currentTime;
        [0, 0.2, 0.4, 0.6, 0.8, 1.0].forEach((t, i) => { this.playNote(400 + i*100, now + t, 0.3); });
    }
}

const Vector = {
    add: (v1, v2) => ({ x: v1.x + v2.x, y: v1.y + v2.y }),
    dist: (p1, p2) => Math.hypot(p2.x - p1.x, p2.y - p1.y)
};

let isPaused = false;

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        this.audio = new AudioController();
        this.level = 1; this.totalScore = 0; this.mirrors = []; this.walls = []; this.particles = [];
        this.maxMirrors = 3; this.won = false; this.reflectedMirrors = new Set();

        this.spawner = document.getElementById('spawner');
        this.trash = document.getElementById('trash-zone');
        this.uiLevel = document.getElementById('level-display');
        this.uiScore = document.getElementById('score-display');
        this.uiMirror = document.getElementById('mirror-display');

        this.draggedMirror = null; this.isDraggingFromUI = false;
        this.bindInput();
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    resize() {
        this.width = this.canvas.clientWidth; this.height = this.canvas.clientHeight;
        this.canvas.width = this.width; this.canvas.height = this.height;
    }

    start() {
        // TAM EKRAN ƒ∞STEƒûƒ∞
        const doc = document.documentElement;
        if (doc.requestFullscreen) doc.requestFullscreen().catch(() => {});
        else if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen();

        this.audio.init();
        document.getElementById('start-screen').classList.add('hidden');
        this.totalScore = 0;
        this.generateLevel(1);
    }

    nextLevel() {
        this.level++;
        if (this.level > 10) { this.endGame(); } 
        else { this.generateLevel(this.level); document.getElementById('win-screen').classList.add('hidden'); }
    }

    endGame() {
        // TAM EKRANDAN √áIK
        if (document.exitFullscreen) document.exitFullscreen().catch(() => {});
        else if (document.webkitExitFullscreen) document.webkitExitFullscreen();

        // Modal g√∂ster - end-screen yerine
        let comment = "";
        if(this.totalScore === 100) comment = "M√úKEMMEL √ñTESƒ∞! üèÜ";
        else if(this.totalScore >= 80) comment = "Harika bir Fizik√ßisin! ‚öõÔ∏è";
        else comment = "Biraz daha √ßalƒ±≈ümalƒ±sƒ±n.";
        
        showGameOverModal(this.totalScore, comment);
    }

    generateLevel(lvl) {
        this.mirrors = []; this.walls = []; this.particles = []; this.won = false; this.level = lvl; this.reflectedMirrors.clear();
        this.maxMirrors = Math.min(3 + Math.floor(lvl / 3), 6); 

        if (lvl === 1) {
            this.source = { x: 0.1, y: 0.5, angle: 0 }; this.target = { x: 0.9, y: 0.8 };
        } else {
            this.source = { x: 0.1, y: Math.random() * 0.6 + 0.2, angle: (Math.random() * 60) - 30 };
            this.target = { x: 0.8 + Math.random() * 0.1, y: Math.random() * 0.6 + 0.2 };
        }

        const wallCount = lvl === 1 ? 0 : Math.floor(lvl / 2) + 1;
        for (let i = 0; i < wallCount; i++) {
            let wx = 0.3 + Math.random() * 0.4; let wy = Math.random() * 0.8 + 0.1;
            this.walls.push({ x: wx, y: wy, w: 0.04, h: 0.15 + Math.random() * 0.15 });
        }
        this.updateUI();
    }

    calculateLevelScore() {
        const used = this.mirrors.length; const max = this.maxMirrors;
        if (used === 0) return 10; if (used >= max) return 0;
        return Math.max(0, Math.round(10 * ((max - used) / (max - 1))));
    }

    handleWin() {
        if (this.won) return;
        this.won = true;
        const score = this.calculateLevelScore();
        this.totalScore += score;
        this.audio.playWin();
        document.getElementById('win-screen').classList.remove('hidden');
        document.getElementById('level-score-detail').innerText = `+${score} Puan`;
        document.getElementById('level-stats').innerText = `Kullanƒ±lan: ${this.mirrors.length} / Limit: ${this.maxMirrors}`;
        this.updateUI();
    }

    updateUI() {
        this.uiLevel.innerText = `B√ñL√úM ${this.level}/10`;
        this.uiScore.innerText = `Puan: ${this.totalScore}`;
        const remaining = this.maxMirrors - this.mirrors.length;
        this.uiMirror.innerText = `Kalan Ayna: ${remaining}`;
        this.uiMirror.style.color = remaining <= 0 ? '#ff0055' : '#00f3ff';
        this.spawner.style.opacity = remaining > 0 ? 1 : 0.3;
        this.spawner.style.pointerEvents = remaining > 0 ? 'all' : 'none';
    }

    bindInput() {
        window.addEventListener('resize', () => this.resize());
        const startDragNew = (e) => {
            if (this.mirrors.length >= this.maxMirrors) return;
            e.preventDefault(); this.isDraggingFromUI = true;
            this.draggedMirror = { x: 0.5, y: 0.9, angle: 135, temp: true, id: Date.now() };
            this.handleMove(e);
        };
        this.spawner.addEventListener('mousedown', startDragNew);
        this.spawner.addEventListener('touchstart', startDragNew, {passive: false});
        this.canvas.addEventListener('mousedown', e => this.handleStart(e));
        this.canvas.addEventListener('mousemove', e => this.handleMove(e));
        this.canvas.addEventListener('mouseup', () => this.handleEnd());
        this.canvas.addEventListener('touchstart', e => this.handleStart(e.touches[0]), {passive: false});
        this.canvas.addEventListener('touchmove', e => { e.preventDefault(); this.handleMove(e.touches[0]); }, {passive: false});
        this.canvas.addEventListener('touchend', () => this.handleEnd());
    }

    getPos(e) {
        const rect = this.canvas.getBoundingClientRect();
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        return { x: (clientX - rect.left) / this.width, y: (clientY - rect.top) / this.height };
    }

    handleStart(e) {
        if(this.won) return;
        const p = this.getPos(e);
        const clicked = this.mirrors.find(m => {
            const dx = (m.x - p.x) * this.width; const dy = (m.y - p.y) * this.height;
            return Math.hypot(dx, dy) < 40;
        });
        if (clicked) { this.draggedMirror = clicked; this.isDraggingFromUI = false; this.clickTime = Date.now(); }
    }

    handleMove(e) {
        if (!this.draggedMirror) return;
        let clientX, clientY;
        if(e.touches && e.touches.length > 0) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
        else { clientX = e.clientX; clientY = e.clientY; }
        const rect = this.canvas.getBoundingClientRect();
        this.draggedMirror.x = Math.max(0, Math.min(1, (clientX - rect.left) / this.width));
        this.draggedMirror.y = Math.max(0, Math.min(1, (clientY - rect.top) / this.height));
        if (this.draggedMirror.y > 0.85 && this.draggedMirror.x > 0.4 && this.draggedMirror.x < 0.6) this.trash.classList.add('active');
        else this.trash.classList.remove('active');
    }

    handleEnd() {
        if (!this.draggedMirror) return;
        const inTrash = (this.draggedMirror.y > 0.85 && this.draggedMirror.x > 0.4 && this.draggedMirror.x < 0.6);
        if (this.isDraggingFromUI) {
            if (!inTrash && this.draggedMirror.y < 0.85) {
                delete this.draggedMirror.temp; this.mirrors.push(this.draggedMirror); this.audio.playPlace();
            }
        } else {
            if (inTrash) { this.mirrors = this.mirrors.filter(m => m !== this.draggedMirror); } 
            else if (Date.now() - this.clickTime < 200) { this.draggedMirror.angle = (this.draggedMirror.angle + 45) % 360; this.audio.playRotate(); } 
        }
        this.draggedMirror = null; this.isDraggingFromUI = false; this.trash.classList.remove('active'); this.updateUI();
    }

    getIntersection(p1, p2, p3, p4) {
        const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y; const x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;
        const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
        if (denom === 0) return null;
        const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
        const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
        if (ua >= 0 && ub >= 0 && ub <= 1) return { x: x1 + ua * (x2 - x1), y: y1 + ua * (y2 - y1), t: ua };
        return null;
    }

    calculateAndDrawRay() {
        if (!this.source) return;
        let startPoint = { x: this.source.x * this.width, y: this.source.y * this.height };
        let rad = this.source.angle * Math.PI / 180; let dir = { x: Math.cos(rad), y: Math.sin(rad) };
        this.ctx.clearRect(0, 0, this.width, this.height);
        
        this.ctx.strokeStyle = 'rgba(255,255,255,0.05)'; this.ctx.lineWidth = 1;
        for(let i=0; i<this.width; i+=50) { this.ctx.beginPath(); this.ctx.moveTo(i,0); this.ctx.lineTo(i,this.height); this.ctx.stroke(); }
        for(let i=0; i<this.height; i+=50) { this.ctx.beginPath(); this.ctx.moveTo(0,i); this.ctx.lineTo(this.width,i); this.ctx.stroke(); }

        this.drawTarget(); this.walls.forEach(w => this.drawWall(w)); this.mirrors.forEach(m => this.drawMirror(m));
        if (this.isDraggingFromUI && this.draggedMirror) { this.ctx.globalAlpha = 0.5; this.drawMirror(this.draggedMirror); this.ctx.globalAlpha = 1.0; }

        this.ctx.beginPath(); this.ctx.arc(startPoint.x, startPoint.y, 8, 0, Math.PI*2);
        this.ctx.fillStyle = '#ff0055'; this.ctx.fill();
        this.ctx.beginPath(); this.ctx.moveTo(startPoint.x, startPoint.y);

        let bounces = 0; const maxBounces = 20; let currentHitMirrors = new Set();
        while (bounces < maxBounces) {
            let closest = null; let minT = Infinity;
            const farPoint = { x: startPoint.x + dir.x * 3000, y: startPoint.y + dir.y * 3000 };
            
            this.walls.forEach(w => {
                const wx = w.x * this.width, wy = w.y * this.height, ww = w.w * this.width / 2, wh = w.h * this.height / 2;
                const lines = [ {p1:{x:wx-ww,y:wy-wh}, p2:{x:wx+ww,y:wy-wh}}, {p1:{x:wx+ww,y:wy-wh}, p2:{x:wx+ww,y:wy+wh}}, {p1:{x:wx+ww,y:wy+wh}, p2:{x:wx-ww,y:wy+wh}}, {p1:{x:wx-ww,y:wy+wh}, p2:{x:wx-ww,y:wy-wh}} ];
                lines.forEach(line => {
                    const hit = this.getIntersection(startPoint, farPoint, line.p1, line.p2);
                    if (hit && hit.t < minT && hit.t > 0.001) { minT = hit.t; closest = { point: hit, type: 'wall' }; }
                });
            });
            this.mirrors.forEach(m => {
                if(m.temp) return;
                const mx = m.x * this.width, my = m.y * this.height, mRad = m.angle * Math.PI / 180;
                const p1 = { x: mx - Math.cos(mRad)*30, y: my - Math.sin(mRad)*30 }; const p2 = { x: mx + Math.cos(mRad)*30, y: my + Math.sin(mRad)*30 };
                const hit = this.getIntersection(startPoint, farPoint, p1, p2);
                if (hit && hit.t < minT && hit.t > 0.001) { minT = hit.t; closest = { point: hit, type: 'mirror', angle: mRad, id: m.id }; }
            });

            const tx = this.target.x * this.width, ty = this.target.y * this.height;
            const vToTarget = { x: tx - startPoint.x, y: ty - startPoint.y };
            const dot = vToTarget.x * dir.x + vToTarget.y * dir.y;
            const distToHit = closest ? Vector.dist(startPoint, closest.point) : Infinity;
            
            if (dot > 0 && dot < distToHit) {
                const closestPointOnLine = { x: startPoint.x + dir.x * dot, y: startPoint.y + dir.y * dot };
                if (Vector.dist({x:tx, y:ty}, closestPointOnLine) < 20) {
                    this.ctx.lineTo(closestPointOnLine.x, closestPointOnLine.y);
                    this.spawnParticles(closestPointOnLine.x, closestPointOnLine.y, '#ffd700', 5);
                    this.handleWin(); break;
                }
            }
            if (closest) {
                this.ctx.lineTo(closest.point.x, closest.point.y); startPoint = { x: closest.point.x, y: closest.point.y };
                if (closest.type === 'mirror') {
                    currentHitMirrors.add(closest.id);
                    if (!this.reflectedMirrors.has(closest.id) && !this.draggedMirror) { this.audio.playReflect(); }
                    const newAngle = 2 * closest.angle - Math.atan2(dir.y, dir.x); dir = { x: Math.cos(newAngle), y: Math.sin(newAngle) };
                } else break;
            } else { this.ctx.lineTo(farPoint.x, farPoint.y); break; }
            bounces++;
        }
        this.reflectedMirrors = currentHitMirrors;
        this.ctx.strokeStyle = '#ff0055'; this.ctx.lineWidth = 3; this.ctx.shadowBlur = 10; this.ctx.shadowColor = '#ff0055'; this.ctx.stroke(); this.ctx.shadowBlur = 0;
        this.updateParticles();
    }

    loop() {
        if (isPaused) {
            requestAnimationFrame(this.loop);
            return;
        }
        this.calculateAndDrawRay();
        requestAnimationFrame(this.loop);
    }
    drawWall(w) {
        const x = w.x * this.width, y = w.y * this.height, wid = w.w * this.width, hei = w.h * this.height;
        this.ctx.fillStyle = '#444'; this.ctx.fillRect(x - wid/2, y - hei/2, wid, hei);
    }
    drawMirror(m) {
        const x = m.x * this.width, y = m.y * this.height;
        this.ctx.save(); this.ctx.translate(x, y); this.ctx.rotate(m.angle * Math.PI / 180);
        this.ctx.fillStyle = '#222'; this.ctx.fillRect(-30, -5, 60, 10);
        this.ctx.strokeStyle = '#00f3ff'; this.ctx.lineWidth = 4; this.ctx.beginPath(); this.ctx.moveTo(-30, 0); this.ctx.lineTo(30, 0); this.ctx.stroke();
        this.ctx.restore();
    }
    drawTarget() {
        const x = this.target.x * this.width, y = this.target.y * this.height;
        this.ctx.beginPath(); this.ctx.arc(x, y, 20, 0, Math.PI*2);
        this.ctx.fillStyle = this.won ? '#ffd700' : '#333'; this.ctx.fill();
        this.ctx.strokeStyle = '#ffd700'; this.ctx.lineWidth = 2; this.ctx.stroke();
    }
    spawnParticles(x, y, color, count) { for(let i=0; i<count; i++) this.particles.push({ x, y, vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5, life: 1, color }); }
    updateParticles() {
        for(let i=this.particles.length-1; i>=0; i--) {
            let p = this.particles[i]; p.x += p.vx; p.y += p.vy; p.life -= 0.05;
            this.ctx.globalAlpha = p.life; this.ctx.fillStyle = p.color; this.ctx.beginPath(); this.ctx.arc(p.x, p.y, 2, 0, Math.PI*2); this.ctx.fill();
            if(p.life <= 0) this.particles.splice(i, 1);
        }
        this.ctx.globalAlpha = 1;
    }
}
window.onload = () => { window.game = new Game(); };
</script>
<script>
/* OYUN SONU FONKSIYONLARI */
function showGameOverModal(puanKazandigi, aciklama) {
    aciklama = aciklama || 'Oyunu tamamladƒ±n!';
    const modal = document.getElementById('gameOverModal');
    if (modal && !modal.classList.contains('showing')) { // Zaten a√ßƒ±lmƒ±≈üsa tekrar a√ßma
        modal.classList.add('showing'); // Marker ekle
        document.getElementById('gameOverTitle').textContent = 'üéÆ Oyun Bitti!';
        document.getElementById('gameOverMessage').textContent = aciklama;
        document.getElementById('earnedPointsDisplay').textContent = puanKazandigi;
        modal.classList.remove('hidden');
    }
    oyunBitti(puanKazandigi);
}

function closeGameOverModal() {
    const modal = document.getElementById('gameOverModal');
    if (modal) {
        modal.classList.add('hidden');
    }
}

function restartGameFromModal() {
    closeGameOverModal();
    location.reload();
}

function oyunBitti(puan) {
    console.log('üéØ Oyun sonu puanƒ±: ' + puan);
    
    // ‚úÖ Flutter'a puan g√∂nder
    if (window.flutter_inappwebview && typeof window.flutter_inappwebview.callHandler === 'function') {
        window.flutter_inappwebview.callHandler('sendScore', puan);
        console.log('‚úÖ Puan Flutter\'e g√∂nderildi: ' + puan);
    }
    
    // Fallback: Eski y√∂ntemler
    if (window.PuanKanali) {
        window.PuanKanali.postMessage(puan.toString());
    }

    if (window.GameBridge && typeof window.GameBridge.sendScore === 'function') {
        window.GameBridge.sendScore(puan, { source: 'gameOver' });
    }

    if (window.sendBadgeForScore) {
        window.sendBadgeForScore(puan);
    }
}

function collectScoreAndExit(puan) {
    console.log('üíæ Puan kabul ediliyor ve oyundan √ßƒ±kƒ±lƒ±yor: ' + puan);
    
    // Tam ekrandan √ßƒ±k
    exitFullscreenMode();
    
    // Butonu disable et - √ßift tƒ±klama preventƒ±
    const collectBtn = document.getElementById('collectScoreBtn');
    if (collectBtn) {
        collectBtn.disabled = true;
        collectBtn.textContent = '‚è≥ ƒ∞≈üleniyor...';
        collectBtn.style.opacity = '0.6';
    }
    
    // Ensure score is sent to Flutter
    if (window.flutter_inappwebview && typeof window.flutter_inappwebview.callHandler === 'function') {
        window.flutter_inappwebview.callHandler('sendScore', puan);
        console.log('‚úÖ Puan Flutter\'e g√∂nderildi: ' + puan);
    }
    
    // Close the game and return to app
    if (window.GameBridge && window.GameBridge.backToApp) {
        window.GameBridge.backToApp();
    } else {
        // Fallback - just navigate back
        history.back();
    }
}

// Tam ekrandan √ßƒ±kma fonksiyonu
function exitFullscreenMode() {
    try {
        if (document.fullscreenElement) {
            document.exitFullscreen();
        } else if (document.webkitFullscreenElement) {
            document.webkitExitFullscreen();
        } else if (document.mozFullScreenElement) {
            document.mozCancelFullScreen();
        } else if (document.msFullscreenElement) {
            document.msExitFullscreen();
        }
        console.log('‚úÖ Tam ekran modu kapatƒ±ldƒ±');
    } catch (err) {
        console.log('‚ö†Ô∏è Tam ekran kapatƒ±lƒ±rken hata:', err);
    }
}

document.addEventListener('DOMContentLoaded', function() {
    const collectScoreBtn = document.getElementById('collectScoreBtn');
    const playAgainBtn = document.getElementById('playAgainBtn');
    const exitBtn = document.getElementById('exitBtn');
    
    if (collectScoreBtn) {
        collectScoreBtn.addEventListener('click', function () {
            const earnedPoints = parseInt(document.getElementById('earnedPointsDisplay').textContent || '0');
            collectScoreAndExit(earnedPoints);
        });
    }
    
    if (playAgainBtn) {
        playAgainBtn.addEventListener('click', restartGameFromModal);
    }
    
    if (exitBtn) {
        exitBtn.addEventListener('click', function () {
            if (window.GameBridge && window.GameBridge.backToApp) {
                window.GameBridge.backToApp();
            }
        });
    }
});
</script>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="gameOverModal hidden">
        <div class="gameOverModalContent">
            <h2 id="gameOverTitle">üéÆ Oyun Bitti!</h2>
            <div class="gameOverInfo">
                <p id="gameOverMessage">Oyunu tamamladƒ±n!</p>
                <p class="earnedPoints">Kazandƒ±ƒüƒ±n Puan: <span id="earnedPointsDisplay">0</span></p>
            </div>
            <div class="gameOverBtnContainer">
                <button id="collectScoreBtn" class="gameOverBtn primary">‚úÖ Puanƒ± Al</button>
                <button id="playAgainBtn" class="gameOverBtn">Tekrar Oyna üîÅ</button>
                <button id="exitBtn" class="gameOverBtn secondary">Ana Menu</button>
            </div>
        </div>
    </div>

    <div id="app-controls" class="app-controls">
        <button id="app-back" class="app-ctrl-btn" type="button">‚üµ</button>
        <button id="app-pause" class="app-ctrl-btn" type="button">‚è∏</button>
        <button id="app-full" class="app-ctrl-btn" type="button">‚õ∂</button>
    </div>

    <div id="pause-overlay" class="pause-overlay hidden">
        <div class="pause-card">
            <h3>Oyun Duraklatildi</h3>
            <button id="pause-resume" class="pause-btn">Devam Et</button>
            <button id="pause-home" class="pause-btn secondary">Ana Menu</button>
        </div>
    </div>

    <div id="badge-toast" class="badge-toast hidden">
        <div class="badge-icon">üèÖ</div>
        <div class="badge-text">
            <div class="badge-title">Rozet Kazandin!</div>
            <div class="badge-name" id="badge-name">Rozet</div>
        </div>
    </div>

    <style>
        .app-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 10001;
            display: flex;
            gap: 8px;
        }
        .app-ctrl-btn {
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.35);
            border-radius: 10px;
            padding: 10px 12px;
            font-size: 16px;
            cursor: pointer;
        }
        .app-ctrl-btn:active { transform: scale(0.96); }
        .pause-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10002;
        }
        .pause-overlay.hidden { display: none; }
        .pause-card {
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 16px;
            padding: 20px 24px;
            color: #fff;
            text-align: center;
            width: 80%;
            max-width: 320px;
        }
        .pause-btn {
            margin-top: 12px;
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            background: #27ae60;
            color: #fff;
        }
        .pause-btn.secondary { background: #34495e; }
        .badge-toast {
            position: fixed;
            left: 16px;
            bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 14px;
            border-radius: 14px;
            background: rgba(15, 15, 20, 0.9);
            color: #fff;
            border: 1px solid rgba(255, 215, 0, 0.6);
            box-shadow: 0 10px 25px rgba(0,0,0,0.35);
            z-index: 10003;
            transform: translateY(20px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .badge-toast.show {
            transform: translateY(0);
            opacity: 1;
        }
        .badge-toast.hidden { display: none; }
        .badge-icon { font-size: 22px; }
        .badge-title { font-size: 12px; color: #ffd966; font-weight: bold; }
        .badge-name { font-size: 14px; font-weight: bold; }
    </style>

    <script>
        (function () {
            function postUi(payload) {
                if (window.GameUi && window.GameUi.postMessage) {
                    window.GameUi.postMessage(JSON.stringify(payload));
                    return true;
                }
                return false;
            }

            function setFullscreen(next) {
                postUi({ type: next ? 'enterFullscreen' : 'exitFullscreen' });
            }

            window.GameBridge = {
                backToApp: function () { postUi({ type: 'back' }); },
                enterFullscreen: function () { setFullscreen(true); },
                exitFullscreen: function () { setFullscreen(false); },
                requestAppData: function () { postUi({ type: 'requestAppData' }); },
                sendEvent: function (event, data) { postUi({ type: 'event', event: event, data: data || {} }); },
                sendScore: function (score, meta) { postUi({ type: 'score', score: Number(score) || 0, meta: meta || {} }); },
            };

            var fullBtn = document.getElementById('app-full');
            var backBtn = document.getElementById('app-back');
            var pauseBtn = document.getElementById('app-pause');
            var pauseOverlay = document.getElementById('pause-overlay');
            var pauseResume = document.getElementById('pause-resume');
            var pauseHome = document.getElementById('pause-home');
            var isFull = false;
            var isPausedLocal = false;

            function setPaused(next) {
                isPausedLocal = next;
                isPaused = next;
                if (pauseOverlay) {
                    pauseOverlay.classList.toggle('hidden', !next);
                }
                if (pauseBtn) {
                    pauseBtn.textContent = next ? '‚ñ∂' : '‚è∏';
                }
            }

            function showBadgeToast(badge) {
                var toast = document.getElementById('badge-toast');
                var nameEl = document.getElementById('badge-name');
                if (!toast || !nameEl || !badge) return;
                nameEl.textContent = badge.name || 'Rozet';
                toast.classList.remove('hidden');
                toast.classList.add('show');
                setTimeout(function () {
                    toast.classList.remove('show');
                }, 1800);
                setTimeout(function () {
                    toast.classList.add('hidden');
                }, 2100);
            }

            window.sendBadgeForScore = function (score) {
                var badge = null;
                if (score >= 90) badge = { id: 'lazer-fizik-ustasi', name: 'Lazer Fizik Ustasi', desc: '90+ puan' };
                else if (score >= 70) badge = { id: 'lazer-fizik-gumus', name: 'Lazer Fizik Gumus', desc: '70+ puan' };
                else if (score >= 40) badge = { id: 'lazer-fizik-bronz', name: 'Lazer Fizik Bronz', desc: '40+ puan' };
                if (badge && window.GameBridge && window.GameBridge.sendEvent) {
                    showBadgeToast(badge);
                    window.GameBridge.sendEvent('badge', badge);
                }
            };

            if (backBtn) backBtn.addEventListener('click', function () { window.GameBridge.backToApp(); });
            if (fullBtn) fullBtn.addEventListener('click', function () {
                isFull = !isFull;
                fullBtn.textContent = isFull ? '‚§°' : '‚õ∂';
                if (isFull) window.GameBridge.enterFullscreen();
                else window.GameBridge.exitFullscreen();
            });
            if (pauseBtn) pauseBtn.addEventListener('click', function () { setPaused(!isPausedLocal); });
            if (pauseResume) pauseResume.addEventListener('click', function () { setPaused(false); });
            if (pauseHome) pauseHome.addEventListener('click', function () { window.GameBridge.backToApp(); });

            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape') window.GameBridge.backToApp();
                if (e.key && e.key.toLowerCase() === 'f' && fullBtn) fullBtn.click();
                if (e.key && e.key.toLowerCase() === 'p' && pauseBtn) pauseBtn.click();
            });

            window.onAppData = function (dataJson) {
                try { window.__appData = JSON.parse(dataJson); } catch (e) {}
            };

            document.addEventListener('DOMContentLoaded', function () {
                window.GameBridge.requestAppData();
                window.GameBridge.sendEvent('ready', { title: document.title });
            });
        })();
    </script>

</body>
</html>